PS C:\Users\Admin\Desktop> clang -help
>>
概述：clang LLVM 编译器

用法：clang.exe [选项] 文件...

选项：
  -### 打印（但不运行）为此编译运行的命令
  --amdgpu-arch-tool=<值>
                          用于检测系统中 AMD GPU 拱门的工具。
  --analyzer-输出 <值>
                          静态分析器报告输出格式（html|plist|plist-multi-file|plist-html|sarif|sarif-html|text）。
  --analyze 运行静态分析器
  -arcmt-迁移-发射-错误
                          即使迁移者可以修复它们，也会发出 ARC 错误
  -arcmt-migrate-report-output <值>
                          plist 报告的输出路径
  -B <prefix> 在 $prefix/$triple-$file 和 $prefix$file 中搜索编译器使用的可执行文件、库、包含和数据文件。$prefix 可能是也可能不是目录
  -CC 在预处理输出中包含来自宏内部的注释
  -cl-denorms-are-zero 仅 OpenCL。允许将非规范化刷新为零。
  -cl-fast-relaxed-math 仅限 OpenCL。设置 -cl-finite-math-only 和 -cl-unsafe-math-optimizations，并定义 __FAST_RELAXED_MATH__。
  -cl-finite-math-only 仅限 OpenCL。允许假设参数和结果不是 NaN 或 +-Inf 的浮点优化。
  -cl-fp32-正确舍入除法-sqrt
                          仅限 OpenCL。指定程序源中使用的单精度浮点除法和 sqrt 正确舍入。
  -cl-kernel-arg-info 仅限 OpenCL。生成内核参数元数据。
  -cl-mad-enable 仅适用于 OpenCL。允许在生成的二进制文件中使用不太精确的 MAD 计算。
  -cl-no-signed-zeros 仅限 OpenCL。允许在生成的二进制文件中使用不太精确的无符号零计算。
  -cl-no-stdinc 仅限 OpenCL。禁用所有包含非本地编译器类型和函数的标准。
  -cl-opt-disable 仅适用于 OpenCL。此选项禁用所有优化。默认情况下启用优化。
  -cl-单精度常数
                          仅限 OpenCL。将双精度浮点常数视为单精度常数。
  -cl-std=<value> 要编译的 OpenCL 语言标准。
  -cl-strict-aliasing 仅限 OpenCL。添加此选项是为了与 OpenCL 1.0 兼容。
  -cl-uniform-work-group-size
                          仅限 OpenCL。定义全局工作大小是指定给 clEnqueueNDRangeKernel 的工作组大小的倍数
  -cl-不安全数学优化
                          仅限 OpenCL。允许不安全的浮点优化。还暗示 -cl-no-signed-zeros 和 -cl-mad-enable。
  --config <value> 指定配置文件
  --cuda-compile-host-device
                          为主机和设备编译 CUDA 代码（默认）。对非 CUDA 编译没有影响。
  --cuda-device-only 仅为设备编译 CUDA 代码
  --cuda-host-only 仅为主机编译 CUDA 代码。对非 CUDA 编译没有影响。
  --cuda-include-ptx=<值>
                          包括以下 GPU 架构的 PTX（例如 sm_35）或“全部”。可以多次指定。
  --cuda-noopt-device-debug
                          启用设备端调试信息生成。禁用 ptxas 优化。
  --cuda-path-ignore-env 忽略环境变量以检测 CUDA 安装
  --cuda-path=<值> CUDA 安装路径
  -cuid=<value> 编译单元ID，同一个编译单元相同，不同编译单元不同。它用于外部化单源卸载语言 CUDA 和 HIP 的设备端静态变量，以便同一编译单元的主机代码可以访问它们。
  -cxx-isystem <目录>
                          将目录添加到 C++ SYSTEM 包含搜索路径
  -C 在预处理输出中包含注释
  -c 只运行预处理、编译和组装步骤
  -dD 除了正常输出之外，在 -E 模式下打印宏定义
  -dependency-dot <value> 将 DOT 格式的标头依赖项写入的文件名
  -依赖文件<值>
                          将依赖项输出写入的文件名（或 -）
  -dI 在 -E 模式下打印除了正常输出之外的指令
  -dM 以 -E 模式打印宏定义而不是正常输出
  -dsym-dir <dir> 输出 dSYM（如果有）的目录
  -D <macro>=<value> 将 <macro> 定义为 <value>（如果 <value> 省略则为 1）
  -emit-ast 为源输入发出 Clang AST 文件
  -emit-interface-stubs 生成接口存根文件。
  -emit-llvm 对汇编程序和目标文件使用 LLVM 表示
  -emit-merged-ifs 生成接口存根文件，发出合并文本而不是二进制文件。
  --emit-static-lib 启用链接器作业以发出静态库。
  -enable-trivial-auto-var-init-zero-knowing-it-will-be-removed-from-clang
                          微不足道的自动变量初始化为零仅用于基准测试，最终将被删除，我对此表示满意，因为我只使用它来进行基准测试
  -E 只运行预处理器
  -faapcs-bitfield-load 遵循 AAPCS 标准，即所有易失性位域写入都会产生至少一个负载。（仅限 ARM）。
  -faapcs-bitfield-width 遵循 AAPCS 标准要求，说明易失性位字段宽度由字段容器类型决定。（仅限 ARM）。
  -f访问控制
  -faddrsig 发出地址意义表
  -faligned-allocation 启用 C++17 对齐分配函数
  -fallow-editor-placeholders
                          将编辑器占位符视为有效的源代码
  -faltivec-src-compat=<值>
                          Altivec 向量的源代码级兼容性（针对 PowerPC 目标）。这包括向量比较的结果（'xl' 的标量，'gcc' 的向量）以及使用标量初始化时的行为（'xl' 的飞溅，仅 'gcc' 的元素零）。对于“混合”，兼容性与“向量布尔/向量像素”的“gcc”和其他类型的“xl”一样。当前默认值为“混合”。
  -fansi-escape-codes 使用 ANSI 转义码进行诊断
  -fapple-kext 使用 Apple 的内核扩展 ABI
  -fapple-link-rtlib 强制链接 clang 内置运行时库
  -fapple-pragma-pack 启用 Apple gcc 兼容的#pragma pack 处理
  -fapplication-extension 将代码限制为可用于应用程序扩展的代码
  -fasm 块
  -fasync-exceptions 启用 EH 异步异常
  -自动链接
  -fbasic-block-sections=<值>
                          将每个函数的基本块放在唯一的部分（仅限 ELF）：全部 | 标签 | 没有 | 列表=<文件>
  -fbinutils-version=<major.minor>
                          生成的目标文件可以使用此 binutils 版本和更高版本支持的所有 ELF 功能。如果指定了 -fno-integrated-as，则生成的程序集会将 GNU 视为支持。'none' 表示可以使用所有 ELF 功能，无论 binutils 支持如何。默认为 2.26。
  -fblocks 启用“块”语言功能
  -fborland-extensions 接受 Borland 编译器支持的非标准结构
  -fbuild-session-file=<文件>
                          使用 <file> 的最后修改时间作为构建会话时间戳
  -fbuild-session-timestamp=<自纪元以来的时间，以秒为单位>
                          当前构建会话开始的时间
  -fbuiltin-module-map 加载 clang 内置模块映射文件。
  -fc++-abi=<值> 要使用的 C++ ABI。这将覆盖目标 C++ ABI。
  -fc++-静态析构函数

  -fcall-saved-x10 使 x10 寄存器调用保存（仅限 AArch64）
  -fcall-saved-x11 使 x11 寄存器调用保存（仅限 AArch64）
  -fcall-saved-x12 使 x12 寄存器调用保存（仅限 AArch64）
  -fcall-saved-x13 使 x13 寄存器调用保存（仅限 AArch64）
  -fcall-saved-x14 使 x14 寄存器调用保存（仅限 AArch64）
  -fcall-saved-x15 使 x15 寄存器调用保存（仅限 AArch64）
  -fcall-saved-x18 使 x18 寄存器调用保存（仅限 AArch64）
  -fcall-saved-x8 使 x8 寄存器调用保存（仅限 AArch64）
  -fcall-saved-x9 使 x9 寄存器调用保存（仅限 AArch64）
  -fcaret 诊断
  -fcf-protection=<值> 仪器控制流架构保护。选项：返回、分支、完整、无。
  -fcf-protection 在“完整”模式下启用 cf-protection
  -fchar8_t 启用 C++ 内置类型 char8_t
  -fclang-abi-compat=<版本>
                          尝试匹配 Clang <version> 的 ABI
  -fcolor-diagnostics 在诊断中启用颜色
  -fcomment-block-commands=<arg>
                          将 <arg> 中的每个逗号分隔参数视为文档注释块命令
  -fcommon 将未初始化的全局变量放在一个公共块中
  -fcomplete-member-pointers
                          如果成员指针基类型在 Microsoft ABI 下很重要，则要求它们是完整的
  -fconstant-cfstrings
  -fconvergent-functions 假设函数可能是收敛的
  -fcoroutines-ts 启用对 C++ Coroutines TS 的支持
  -fcoverage-compilation-dir=<值>
                          要嵌入到覆盖映射中的编译目录。
  -fcoverage-mapping 生成覆盖映射以启用代码覆盖分析
  -fcoverage-prefix-map=<值>
                          在覆盖映射中重新映射文??件源路径
  -fcrash-diagnostics-dir=<目录>
                          将崩溃报告文件放入 <dir>
  -fcs-profile-generate=<目录>
                          生成检测代码以将上下文相关的执行计数收集到 <directory>/default.profraw（由 LLVM_PROFILE_FILE env var 覆盖）
  -fcs-profile-generate 生成检测代码以将上下文相关的执行计数收集到 default.profraw （由 LLVM_PROFILE_FILE env var 覆盖）
  -fcuda-近似超越
                          使用近似超越函数
  -fcuda-short-ptr 使用 32 位指针访问 const/local/shared 地址空间
  -fcxx-exceptions 启用 C++ 异常
  -fdata-sections 将每个数据放在自己的部分中
  -fdebug-compilation-dir=<值>
                          嵌入调试信息的编译目录
  -fdebug-default-version=<值>
                          要使用的默认 DWARF 版本，如果 -g 选项导致生成 DWARF 调试信息
  -fdebug-info-for-profiling
                          发出额外的调试信息以使示例配置文件更准确
  -fdebug-macro 发出宏调试信息
  -fdebug-prefix-map=<值>
                          在调试信息中重新映射文??件源路径
  -fdebug-ranges-基地址
                          在 .debug_ranges 中使用 DWARF 基地址选择条目
  -fdebug-types-section 将调试类型放在它们自己的部分中（仅限 ELF）
  -fdeclspec 允许 __declspec 作为关键字
  -fdelayed-模板解析
                          在翻译单元末尾解析模板化函数定义
  -fdelete-null-pointer-checks
                          将空指针的使用视为未定义的行为（默认）
  -fdiagnostics-绝对路径
                          在诊断中打印绝对路径
  -fdiagnostics-hotness-threshold=<值>
                          如果优化备注至少没有此配置文件计数，则防止输出优化备注。使用“自动”应用配置文件摘要中的阈值
  -fdiagnostics-parseable-fixits
                          以机器可解析的形式打印 fix-its
  -fdiagnostics-打印-源-范围-信息
                          以数字形式打印源范围
  -fdiagnostics-show-hotness
                          在诊断行中启用配置文件热度信息
  -fdiagnostics-show-note-include-stack
                          显示包括诊断说明的堆栈
  -fdiagnostics 显示选项
                          打印带有可映射诊断的选项名称
  -fdiagnostics 显示模板树
                          打印不同模板的模板比较树
  -fdigraphs 启用替代标记表示 '<:'、':>'、'<%'、'%>'、'%:'、'%:%:'（默认）
  -fdirect 访问外部数据
                          不要使用 GOT 间接引用外部数据符号
  -fdiscard-value-names 丢弃 LLVM IR 中的值名称
  -fdollars-in-identifiers
                          允许在标识符中使用“$”
  -f双方括号属性
                          在所有 C 和 C++ 语言模式下启用“[[]]”属性
  -fdwarf-目录-asm
  -fdwarf-exceptions 使用 DWARF 样式的异常
  -felide 构造函数
  -feliminate-未使用的调试类型
                          不要为已定义但未使用的类型发出调试信息
  -fembed-bitcode-marker 嵌入占位符 LLVM IR 数据作为标记
  -fembed-bitcode=<选项>
                          嵌入 LLVM 位码（选项：关闭、全部、位码、标记）
  -fembed-bitcode 嵌入 LLVM IR 位码作为数据
  -femit-all-decls 发出所有声明，即使未使用
  -femulated-tls 使用 emutls 函数访问 thread_local 变量
  -fenable-matrix 启用矩阵数据类型和相关的内置函数
  -fescaping-block-tail-calls

  -fexceptions 启用对异常处理的支持
  -fexperimental-new-constant-interpreter
                          启用实验性的新常量解释器
  -fexperimental-relative-c++-abi-vtables
                          将实验性 C++ 类 ABI 用于具有虚拟表的类
  -实验性严格浮点
                          在 LLVM 中启用实验性严格浮点。
  -fextend-arguments=<值>
                          控制在对非原型函数和可变参数函数的调用中如何扩展标量整数参数
  -ffast-math 允许积极的有损浮点优化
  -ffile-compilation-dir=<值>
                          嵌入调试信息和覆盖映射的编译目录。
  -ffile-prefix-map=<值>
                          在调试信息、预定义的预处理器宏和 __builtin_FILE() 中重新映射文??件源路径
  -细粒度位域访问
                          对具有合法宽度和对齐方式的连续位域运行使用单独的访问。
  -ffinite-loops 假设所有循环都是有限的。
  -仅有限数学
  -fixed-a0 保留 a0 寄存器（仅限 M68k）
  -fixed-a1 保留 a1 寄存器（仅限 M68k）
  -fixed-a2 保留 a2 寄存器（仅限 M68k）
  -fixed-a3 保留 a3 寄存器（仅限 M68k）
  -fixed-a4 保留 a4 寄存器（仅限 M68k）
  -fixed-a5 保留 a5 寄存器（仅限 M68k）
  -fixed-a6 保留 a6 寄存器（仅限 M68k）
  -fixed-d0 保留 d0 寄存器（仅限 M68k）
  -fixed-d1 保留 d1 寄存器（仅限 M68k）
  -fixed-d2 保留 d2 寄存器（仅限 M68k）
  -fixed-d3 保留 d3 寄存器（仅限 M68k）
  -fixed-d4 保留 d4 寄存器（仅限 M68k）
  -fixed-d5 保留 d5 寄存器（仅限 M68k）
  -fixed-d6 保留 d6 寄存器（仅限 M68k）
  -fixed-d7 保留 d7 寄存器（仅限 M68k）
  -fixed-point 启用定点类型
  -fixed-r19 保留寄存器 r19（仅限六边形）
  -fixed-r9 保留 r9 寄存器（仅限 ARM）
  -fixed-x10 保留 x10 寄存器（仅限 AArch64/RISC-V）
  -fixed-x11 保留 x11 寄存器（仅限 AArch64/RISC-V）
  -fixed-x12 保留 x12 寄存器（仅限 AArch64/RISC-V）
  -fixed-x13 保留 x13 寄存器（仅限 AArch64/RISC-V）
  -fixed-x14 保留 x14 寄存器（仅限 AArch64/RISC-V）
  -fixed-x15 保留 x15 寄存器（仅限 AArch64/RISC-V）
  -fixed-x16 保留 x16 寄存器（仅限 AArch64/RISC-V）
  -fixed-x17 保留 x17 寄存器（仅限 AArch64/RISC-V）
  -fixed-x18 保留 x18 寄存器（仅限 AArch64/RISC-V）
  -fixed-x19 保留 x19 寄存器（仅限 AArch64/RISC-V）
  -fixed-x1 保留 x1 寄存器（仅限 AArch64/RISC-V）
  -fixed-x20 保留 x20 寄存器（仅限 AArch64/RISC-V）
  -fixed-x21 保留 x21 寄存器（仅限 AArch64/RISC-V）
  -fixed-x22 保留 x22 寄存器（仅限 AArch64/RISC-V）
  -fixed-x23 保留 x23 寄存器（仅限 AArch64/RISC-V）
  -fixed-x24 保留 x24 寄存器（仅限 AArch64/RISC-V）
  -fixed-x25 保留 x25 寄存器（仅限 AArch64/RISC-V）
  -fixed-x26 保留 x26 寄存器（仅限 AArch64/RISC-V）
  -fixed-x27 保留 x27 寄存器（仅限 AArch64/RISC-V）
  -fixed-x28 保留 x28 寄存器（仅限 AArch64/RISC-V）
  -fixed-x29 保留 x29 寄存器（仅限 AArch64/RISC-V）
  -fixed-x2 保留 x2 寄存器（仅限 AArch64/RISC-V）
  -fixed-x30 保留 x30 寄存器（仅限 AArch64/RISC-V）
  -fixed-x31 保留 x31 寄存器（仅限 AArch64/RISC-V）
  -fixed-x3 保留 x3 寄存器（仅限 AArch64/RISC-V）
  -fixed-x4 保留 x4 寄存器（仅限 AArch64/RISC-V）
  -fixed-x5 保留 x5 寄存器（仅限 AArch64/RISC-V）
  -fixed-x6 保留 x6 寄存器（仅限 AArch64/RISC-V）
  -fixed-x7 保留 x7 寄存器（仅限 AArch64/RISC-V）
  -fixed-x8 保留 x8 寄存器（仅限 AArch64/RISC-V）
  -fixed-x9 保留 x9 寄存器（仅限 AArch64/RISC-V）
  -fforce-dwarf-frame 始终发出调试帧部分
  -fforce-emit-vtables 发出更多虚拟表以改进去虚拟化
  -fforce-enable-int128 启用对 int128_t 类型的支持
  -ffp-contract=<值> Form fused FP ops (eg FMAs): fast (fuses across statements而忽略pragma) | on（仅在同一语句中融合，除非由 pragma 指定）| 关闭（从不熔断） | fast-honor-pragmas（在语句之间融合，除非由 pragma 决定）。CUDA 的默认值为“fast”，HIP 的默认值为“fast-honor-pragmas”，否则为“on”。
  -ffp-异常行为=<值>
                          指定浮点运算的异常行为。
  -ffp-model=<值> 控制浮点计算的语义。
  -ffreestanding 断言编译发生在独立环境中
  -ffunction-sections 将每个函数放在自己的部分中
  -fglobal-isel 启用全局指令选择器
  -fgnu-inline-asm
  -fgnu-keywords 允许 GNU 扩展关键字，无论语言标准如何
  -fgnu-runtime 生成与标准 GNU Objective-C 运行时兼容的输出
  -fgnu89-inline 使用 gnu89 内联语义
  -fgnuc-version=<值> 设置各种宏以声明与给定 GCC 版本的兼容性（默认为 4.2.1）
  -fgpu-allow-device-init 在 HIP 中允许设备端初始化功能（实验性）
  -fgpu-defer-diag 延迟 CUDA/HIP 的主机/设备相关诊断消息
  -fgpu-flush-denormals-to-zero
                          在 CUDA/HIP 设备模式下将非正规浮点值刷新为零。
  -fgpu-rdc 生成可重定位设备代码，也称为分离编译模式
  -fgpu-sanitize 为 AMDGPU 目标启用 sanitizer
  -fhip-fp32-正确舍入除法-sqrt
                          指定程序源中使用的单精度浮点除法和 sqrt 正确舍入（仅限 HIP 设备编译）
  -fhip-new-launch-api 为 HIP 使用新的内核启动 API
  -fignore-exceptions 启用对忽略异常处理结构的支持
  -fimplicit-module-maps 隐式搜索文件系统以查找模块映射文件。
  -fimplicit-modules
  -finline-functions 内联合适的函数
  -finline-hint-functions 内联函数（显式或隐式）标记为内联
  -finput-charset=<值> 指定源文件的默认字符集
  -finstrument-function-entry-bare
                          仅仪器函数入口，在内联之后，没有仪器调用的参数
  -finstrument-functions-内联后
                          与 -finstrument-functions 类似，但在内联后插入调用
  -finstrument-functions 生成对仪器函数入口和出口的调用
  -fintegrated-as 启用集成汇编器
  -fintegrated-cc1 在进程内运行 cc1
  -fjump-tables 使用跳转表来降低开关
  -fkeep-static-consts 如果未使用，保留静态 const 变量
  -flax-vector-conversions=<值>
                          启用隐式向量位转换
  -flegacy-pass-manager 在 LLVM 中使用传统的 pass 管理器
  -flto-jobs=<value> 控制 -flto=thin 的后端并行度（默认为 0 表示线程数将根据检测到的 CPU 数得出）
  -flto=<值> 将 LTO 模式设置为“完整”或“精简”
  -flto 在“完整”模式下启用 LTO
  -fmacro-prefix-map=<值>
                          在预定义的预处理器宏和 __builtin_FILE() 中重新映射文??件源路径
  -fmath-errno 要求数学函数通过设置 errno 来指示错误
  -fmax-tokens=<值> -Wmax-tokens 的最大预处理令牌总数。
  -fmax-type-align=<值>
                          指定对缺少显式对齐的指针强制执行的最大对齐
  -fmemory-profile=<目录>
                          启用堆内存分析并将结果转储到 <directory>
  -fmemory-profile 启用堆内存分析
  -fmerge-all-constants 允许合并常量
  -fmessage-length=<值>
                          格式化消息诊断，使其适合 N 列
  -fmodule-file=[<名称>=]<文件>
                          指定模块名称到预编译模块文件的映射，如果省略名称，则加载模块文件。
  -fmodule-map-file=<文件>
                          加载此模块映射文件
  -fmodule-name=<name> 指定要构建的模块的名称
  -fmodules-cache-path=<目录>
                          指定模块缓存路径
  -fmodules-decluse 需要声明模块中使用的模块
  -fmodules-禁用-诊断-验证
                          加载模块时禁用诊断选项的验证
  -fmodules-ignore-macro=<值>
                          构建和加载模块时忽略给定宏的定义
  -fmodules-prune-after=<秒>
                          指定模块文件将被视为未使用的时间间隔（以秒为单位）
  -fmodules-prune-interval=<秒>
                          指定尝试修剪模块缓存的时间间隔（以秒为单位）
  -fmodules-search-all 甚至搜索非导入的模块来解析引用
  -fmodules-严格-排除
                          与 -fmodules-decluse 类似，但要求所有标头都在模块中
  -fmodules-ts 启用对 C++ 模块 TS 的支持
  -fmodules-user-build-path <目录>
                          指定模块用户构建路径
  -fmodules-validate-input-files-content
                          如果 mtime 不同，则根据内容验证 PCM 输入文件
  -fmodules-validate-once-per-build-session
                          如果在此构建会话期间模块已成功验证或加载，则不要验证模块的输入文件
  -fmodules-validate-system-headers
                          在加载模块时验证模块所依赖的系统头文件
  -fmodules 启用“模块”语言功能
  -fms-compatibility-version=<值>
                          表示要在 _MSC_VER 中报告的 Microsoft 编译器版本号的点分隔值（0 = 不定义它（默认））
  -fms-compatibility 启用完全的 Microsoft Visual C++ 兼容性
  -fms-extensions 接受微软编译器支持的一些非标准结构
  -fmsc-version=<值> Microsoft 编译器版本号在 _MSC_VER 中报告（0 = 不定义它（默认））
  -fnew-alignment=<align> 指定 '::operator new(size_t)' 保证的最大对齐
  -fno-aapcs-位域宽度
                          不要遵循 AAPCS 标准要求，即易失性位字段宽度由字段容器类型决定。（仅限 ARM）。
  -fno-access-control 禁用 C++ 访问控制
  -fno-addrsig 不发出地址有效表
  -fno-aligned-allocation
  -fno-allow-editor-placeholders

  -fno-apple-pragma-pack
  -fno-应用程序扩展

  -fno-asm-blocks
  -fno-assume-sane-operator-new
                          不要假设 C++ 的全局操作符 new 不能为任何指针起别名
  -fno-async-exceptions
  -fno-autolink 禁止为自动库链接生成链接器指令
  -fno-blocks
  -fno-borland-extensions
  -fno-builtin-<value> 禁用特定函数的隐式内置知识
  -fno-builtin 禁用函数的隐式内置知识
  -fno-c++-静态析构函数
                          禁用 C++ 静态析构函数注册
  -fno-caret-诊断
  -fno-char8_t 禁用 C++ 内置类型 char8_t
  -fno-color-diagnostics 禁用诊断中的颜色
  -fno-common 像普通定义一样编译通用全局变量
  -fno-complete-member-pointers
                          如果成员指针基类型在 Microsoft ABI 下很重要，则不要求它们是完整的
  -fno-constant-cfstrings 禁止创建 CodeFoundation 类型的常量字符串
  -fno-coroutines-ts
  -fno-coverage-mapping 禁用代码覆盖率分析
  -fno-crash-diagnostics 在clang崩溃期间禁用预处理源文件和复制脚本的自动生成
  -fno-cuda-近似超越
                          不要使用近似超越函数
  -fno-cuda-short-ptr
  -fno-cxx-异常
  -fno 数据部分
  -fno-debug-info-for-profiling

  -fno-debug-macro 不发出宏调试信息
  -fno-debug-ranges-base-address

  -fno-declspec 禁止将 __declspec 作为关键字
  -fno 延迟模板解析
                          禁用延迟模板解析
  -fno-delete-null-pointer-checks
                          不要将空指针的使用视为未定义的行为
  -fno-诊断-修复信息
                          不要在诊断中包含 fixit 信息
  -fno-diagnostics-show-hotness

  -fno-diagnostics-show-note-include-stack

  -fno 诊断显示选项

  -fno-digraphs 禁止替代标记表示 '<:'、':>'、'<%'、'%>'、'%:'、'%:%:'
  -fno-直接访问-外部数据
                          使用 GOT 间接引用外部数据符号
  -fno-discard-value-names
                          不要丢弃 LLVM IR 中的值名称
  -fno-dollars-in-identifiers
                          不允许在标识符中使用“$”
  -fno-双方括号属性
                          在所有 C 和 C++ 语言模式下禁用“[[]]”属性
  -fno-dwarf-目录-asm

  -fno-elide-constructors 禁用 C++ 复制构造函数省略
  -fno-elide-type 打印诊断时不要省略类型
  -fno-eliminate-unused-debug-types
                          为已定义但未使用的类型发出调试信息
  -fno-仿真-tls
  -fno-escaping-block-tail-calls

  -fno-exceptions 禁用对异常处理的支持
  -fno-experimental-relative-c++-abi-vtables
                          不要将实验性 C++ 类 ABI 用于具有虚拟表的类
  -fno-快速数学
  -fno-fine-grained-bitfield-accesses
                          对连续的位域运行使用大整数访问。
  -fno-finite-loops 不要假设任何循环都是有限的。
  -fno-finite-math-only
  -fno-fixed-point 禁用定点类型
  -fno-force-dwarf-frame
  -fno-force-emit-vtables
  -fno-force-enable-int128
                          禁用对 int128_t 类型的支持
  -fno-function-sections
  -fno-global-isel 禁用全局指令选择器
  -fno-gnu-inline-asm 禁用 GNU 风格的内联 asm
  -fno-gnu-keywords
  -fno-gnu89-内联
  -fno-gpu-allow-device-init
                          不允许在 HIP 中使用设备端初始化功能（实验性）
  -fno-gpu-defer-diag 不要为 CUDA/HIP 延迟主机/设备相关的诊断消息
  -fno-gpu-rdc
  -fno-hip-fp32-正确舍入除法-sqrt
                          不要指定程序源中使用的单精度浮点除法和 sqrt 是否正确舍入（仅限 HIP 设备编译）
  -fno-hip-new-launch-api 不要为 HIP 使用新的内核启动 API
  -fno-隐式模块
  -fno-integrated-as 禁用集成汇编器
  -fno-integrated-cc1 为每个 cc1 生成一个单独的进程
  -fno-jump-tables 不要使用跳转表来降低开关
  -fno-keep-static-consts 如果未使用，不要保留静态 const 变量
  -fno-legacy-pass-manager
                          在 LLVM 中使用新的通行证管理器
  -fno-lto 禁用 LTO 模式（默认）
  -fno-math-errno
  -fno-memory-profile 禁用堆内存分析
  -fno-merge-all-constants
                          禁止合并常量
  -fno-modules-decluse
  -fno 模块搜索全部
  -fno-modules-validate-system-headers

  -fno 模块
  -fno-objc-arc-异常

  -fno-objc-convert-messages-to-runtime-calls

  -fno-objc-encode-cxx-class-template-spec

  -fno-objc-异常
  -fno-objc-infer-related-result-type
                          不要根据方法族推断 Objective-C 相关的结果类型
  -fno-offload-lto 为卸载编译禁用 LTO 模式（默认）
  -fno-openmp-target-new-runtime

  -fno-operator-names 不要将 C++ 运算符名称关键字视为运算符的同义词
  -fno-pascal 字符串
  -fno-pch-codegen 不生成使用此 PCH 的代码，假定将为 PCH 构建显式目标文件
  -fno-pch-debuginfo 不为从此 PCH 构建的目标文件中的类型生成调试信息，也不在其他地方生成它们
  -fno-pch-instantiate-templates

  -fno-plt 使用 GOT 间接而不是 PLT 进行外部函数调用（仅限 x86）
  -fno-prebuilt-implicit-modules

  -fno-preserve-as-comments
                          不要在内联汇编中保留注释
  -fno-profile-arcs
  -fno-profile-generate 禁用配置文件检测的生成。
  -fno-profile-instr-generate
                          禁用配置文件检测的生成。
  -fno-profile-instr-use 禁用使用检测数据进行配置文件引导优化
  -fno-protect-parens
  -fno-pseudo-probe-for-profiling
                          不要发出用于样品分析的伪探针
  -fno-倒数-数学
  -fno-register-global-dtors-with-atexit
                          不要使用 atexit 或 __cxa_atexit 注册全局析构函数
  -fno-relaxed-template-template-args

  -fno-reroll-loops
  -fno-rewrite-imports
  -fno-rewrite-includes
  -fno-ropi
  -fno-rtlib-add-rpath 不要将具有体系结构特定资源目录的 -rpath 添加到链接器标志
  -fno-rtti-data 禁止生成 RTTI 数据
  -fno-rtti 禁止生成 rtti 信息
  -fno-rwpi
  -fno-sanitize-address-outline-instrumentation
                          为地址清理程序使用默认代码内联逻辑
  -fno-sanitize-address-poison-custom-array-cookie
                          在 AddressSanitizer 中使用自定义运算符 new[] 时禁用中毒数组 cookie
  -fno-sanitize-address-use-after-scope
                          在 AddressSanitizer 中禁用 use-after-scope 检测
  -fno-sanitize-address-use-odr-indicator
                          禁用 ODR 指标全局变量
  -fno-sanitize-cfi-canonical-jump-tables
                          不要使跳转表地址在符号表中规范
  -fno-sanitize-cfi-cross-dso
                          禁用跨 DSO 调用的控制流完整性 (CFI) 检查。
  -fno-sanitize-coverage=<值>
                          禁用 Sanitizers 的覆盖检测功能
  -fno-sanitize-hwaddress-experimental-aliasing
                          在 HWAddressSanitizer 中禁用别名模式
  -fno-sanitize-ignorelist
                          不要将 ignorelist 文件用于消毒剂
  -fno-sanitize-memory-track-origins
                          在 MemorySanitizer 中禁用源跟踪
  -fno-sanitize-memory-use-after-dtor
                          在 MemorySanitizer 中禁用 use-after-destroy 检测
  -fno-sanitize-minimal-runtime

  -fno-sanitize-recover=<值>
                          禁用指定消毒剂的恢复
  -fno-sanitize-stats 禁用消毒剂统计信息收集。
  -fno-sanitize-thread-atomics
                          在 ThreadSanitizer 中禁用原子操作检测
  -fno-sanitize-thread-func-entry-exit
                          在 ThreadSanitizer 中禁用函数进入/退出检测
  -fno-sanitize-thread-memory-access
                          在 ThreadSanitizer 中禁用内存访问检测
  -fno-sanitize-trap=<值>
                          禁用指定消毒剂的诱捕
  -fno-sanitize-trap 禁用所有消毒剂的陷阱
  -fno 语义插入

  -fno-short-enums
  -fno-short-wchar 强制 wchar_t 为无符号整数
  -fno-show-column 不要在诊断中包含列号
  -fno-show-源位置
                          不要在诊断中包含源位置信息
  -fno-signed-char 字符是无符号的
  -fno-signed-zeros 允许忽略浮点零符号的优化
  -fno-sized-deallocation
  -fno-spell-checking 禁用拼写检查
  -fno-split-dwarf-inlining

  -fno-split-lto-unit
  -fno-split-machine-functions
                          使用配置文件信息禁用后期函数拆分 (x86 ELF)
  -fno-split-stack 不使用分段堆栈
  -fno-stack-clash-protection
                          禁用堆栈冲突保护
  -fno-stack-protector 禁用堆栈保护器
  -fno-stack-size-section
  -fno-standalone-debug 限制生成的调试信息以减小调试二进制文件的大小
  -fno-strict-float-cast-overflow
                          放宽语言规则并尝试匹配目标本机浮点到整数转换指令的行为
  -fno-strict-return 不要将脱离非空函数末尾的控制流路径视为不可访问
  -fno-strict-vtable-pointers

  -fno-sycl 禁用设备的 SYCL 内核编译
  -fno-temp-file 直接创建编译输出文件。如果编译器崩溃，这可能会导致不正确的增量构建
  -fno-测试覆盖率
  -fno-threadsafe-statics 不发出代码以使本地静态线程的初始化安全
  -fno-trigraphs 不处理三元组序列
  -fno-unique-basic-block-section-names

  -fno-unique-internal-linkage-names

  -fno-unique-section-names
                          不要为文本和数据部分使用唯一的名称
  -fno-unroll-loops 关闭循环展开器
  -fno-use-cxa-atexit 不要使用 __cxa_atexit 调用析构函数
  -fno-use-init-array 使用 .ctors/.dtors 而不是 .init_array/.fini_array
  -fno-use-line-directives

  -fno-虚函数消除

  -fno-visibility-from-dllstorageclass

  -fno-visibility-inlines-hidden-static-local-var
                          禁用 -fvisibility-inlines-hidden-static-local-var（这是非 darwin 目标的默认设置）
  -fno-visibility-inlines-hidden

  -fno-whole-program-vtables

  -fno-xl-pragma-pack
  -fno-xray-always-emit-customevents

  -fno-xray-always-emit-typedevents

  -fno-xray-function-index
                          以单功能补丁性能为代价省略功能索引部分
  -fno-xray-忽略循环
  -fno-x 射线仪器
  -fno-zero-initialized-in-bss
                          不要在 BSS 中放置零初始化数据
  -fno-zvector
  -fobjc-arc-exceptions 在 -fobjc-arc 中合成保留和释放时使用 EH 安全代码
  -fobjc-arc 合成对 Objective-C 指针的保留和释放调用
  -fobjc-convert-messages-to-runtime-calls

  -fobjc-disable-direct-methods-for-testing
                          忽略属性 objc_direct 以便可以测试直接方法
  -fobjc-encode-cxx-class-template-spec
                          完全编码 c++ 类模板特化
  -fobjc-exceptions 启用 Objective-C 异常
  -fobjc-推断相关结果类型

  -fobjc-runtime=<值> 指定目标 Objective-C 运行时种类和版本
  -fobjc-weak 在 Objective-C 中启用 ARC 风格的弱引用
  -foffload-lto=<值> 将 LTO 模式设置为“完整”或“精简”以进行卸载编译
  -foffload-lto 在“完整”模式下启用 LTO 以进行卸载编译
  -fopenmp-simd 仅针对基于 SIMD 的构造发出 OpenMP 代码。
  -fopenmp-target-new-runtime
                          使用新的位码库进行 OpenMP 卸载
  -fopenmp-targets=<值>
                          指定要支持的三元组 OpenMP 卸载目标的逗号分隔列表
  -fopenmp 解析 OpenMP 编译指示并生成并行代码。
  -foperator 名称
  -foptimization-record-file=<文件>
                          指定包含优化备注的文件的输出名称。暗示 -fsave-optimization-record。在 Darwin 平台上，这不能与多个 -arch <arch> 选项一起使用。
  -foptimization-record-passes=<正则表达式>
                          在生成的优化记录中只包含匹配指定正则表达式的pass（默认包含所有pass）
  -forder-file-instrumentation
                          生成检测代码以将订单文件收集到 default.profraw 文件中（被 '=' 形式的选项或 LLVM_PROFILE_FILE env var 覆盖）
  -fpack-struct=<value> 指定默认的最大结构打包对齐方式
  -fpascal-strings 识别和构造 Pascal 风格的字符串文字
  -fpass-plugin=<dsopath> 从动态共享对象文件加载 pass 插件（仅适用于新的 pass 管理器）。
  -fpatchable-function-entry=<N,M>
                          在函数入口前生成 M 个 NOP，在函数入口后生成 NM 个 NOP
  -fpcc-struct-return 覆盖默认 ABI 以返回堆栈上的所有结构
  -fpch-codegen 为使用此 PCH 生成代码，假定将为 PCH 构建显式目标文件
  -fpch-debuginfo 为从此 PCH 构建的目标文件中的类型生成调试信息，并且不在其他地方生成它们
  -fpch-实例化模板
                          在构建 PCH 时已经实例化模板
  -fpch-验证输入文件内容
                          如果 mtime 不同，则根据内容验证 PCH 输入文件
  -fplt
  -fplugin=<dsopath> 加载命名插件（动态共享对象）
  -fprebuilt-implicit-modules
                          在预建模块路径中查找隐式模块
  -fprebuilt-module-path=<目录>
                          指定预建模块路径
  -fpreserve-as-comments
  -fproc-stat-report=<值>
                          将子进程统计信息保存到给定文件
  -fproc-stat-report<值>
                          打印子进程统计
  -fprofile-arcs
  -fprofile-exclude-files=<值>
                          仪器仅适用于名称与所有由分号分隔的正则表达式不匹配的文件
  -fprofile-filter-files=<值>
                          仪器仅从名称与任何用分号分隔的正则表达式匹配的文件中起作用
  -fprofile-generate=<目录>
                          生成检测代码以将执行计数收集到 <directory>/default.profraw（由 LLVM_PROFILE_FILE env var 覆盖）
  -fprofile-generate 生成检测代码以将执行计数收集到 default.profraw（由 LLVM_PROFILE_FILE env var 覆盖）
  -fprofile-instr-generate=<文件>
                          生成检测代码以将执行计数收集到 <file> 中（由 LLVM_PROFILE_FILE env var 覆盖）
  -fprofile-instr-generate
                          生成检测代码以将执行计数收集到 default.profraw 文件中（被选项的“=”形式或 LLVM_PROFILE_FILE env var覆盖）
  -fprofile-instr-use=<值>
                          使用仪表数据进行配置文件引导优化
  -fprofile-list=<值> 定义要检测的函数/文件列表的文件名
  -fprofile-remapping-file=<文件>
                          使用 <file> 中描述的重新映射将配置文件数据与程序中的名称匹配
  -fprofile-sample-accurate
                          指定样本配置文件是准确的
  -fprofile-sample-use=<值>
                          启用基于样本的配置文件引导优化
  -fprofile-update=<方法>
                          设置配置文件计数器的更新方法 (atomic,prefer-atomic,single)
  -fprofile-use=<路径名>
                          使用检测数据进行配置文件引导优化。如果 pathname 是一个目录，它从 <pathname>/default.profdata 读取。否则，它从文件 <路径名> 中读取。
  -fprotect-parens 确定优化器在计算浮点表达式时是否支持括号
  -fpseudo-probe-for-profiling
                          发射用于样品分析的伪探针
  -freciprocal-math 允许重新关联除法运算
  -freg-struct-return 覆盖默认 ABI 以在寄存器中返回小结构
  -fregister-global-dtors-with-atexit
                          使用 atexit 或 __cxa_atexit 注册全局析构函数
  -frelaxed-template-template-args
                          启用 C++17 宽松模板模板参数匹配
  -freroll-loops 打开循环重滚器
  -frewrite-imports
  -frewrite-包括
  -fropi 生成只读位置无关代码（仅限 ARM）
  -frtlib-add-rpath 将具有特定于体系结构的资源目录的 -rpath 添加到链接器标志
  -frtti-数据
  -frtti
  -frwpi 生成读写位置无关代码（仅限 ARM）
  -fsanitize-address-destructor=<值>
                          设置 ASan 检测中使用的析构函数类型
  -fsanitize-address-field-padding=<值>
                          AddressSanitizer 的字段填充级别
  -fsanitize-address-globals-dead-stripping
                          在 AddressSanitizer 中启用全局变量的链接器死剥离
  -fsanitize-address-outline-instrumentation
                          始终为地址清理工具生成函数调用
  -fsanitize-address-poison-custom-array-cookie
                          在 AddressSanitizer 中使用自定义运算符 new[] 时启用中毒数组 cookie
  -fsanitize-address-use-after-return=<模式>
                          在 AddressSanitizer 中选择检测堆栈使用后返回的模式：从不 | 运行时（默认） | 总是
  -fsanitize-address-use-after-scope
                          在 AddressSanitizer 中启用 use-after-scope 检测
  -fsanitize-address-use-odr-indicator
                          启用 ODR 指示器全局变量以避免在部分清理的程序中出现错误的 ODR 违规报告，但会增加二进制大小
  -fsanitize-blacklist=<值>
                          -fsanitize-ignorelist= 的别名
  -fsanitize-cfi-canonical-jump-tables
                          使跳转表地址在符号表中规范
  -fsanitize-cfi-cross-dso
                          为跨 DSO 调用启用控制流完整性 (CFI) 检查。
  -fsanitize-cfi-icall-generalize-pointers
                          在 CFI 间接调用类型签名检查中泛化指针
  -fsanitize-coverage-allowlist=<值>
                          将消毒剂覆盖检测仅限于与提供的特殊情况列表匹配的模块和功能，被阻止的除外
  -fsanitize-coverage-blacklist=<值>
                          已弃用，请改用 -fsanitize-coverage-ignorelist=
  -fsanitize-coverage-ignorelist=<值>
                          禁用与提供的特殊情况列表匹配的模块和功能的消毒剂覆盖检测，即使是允许的
  -fsanitize-coverage-whitelist=<值>
                          已弃用，请改用 -fsanitize-coverage-allowlist=
  -fsanitize-coverage=<值>
                          指定 Sanitizers 的覆盖检测类型
  -fsanitize-hwaddress-abi=<值>
                          选择要定位的 HWAddressSanitizer ABI（拦截器或平台，默认拦截器）。此选项当前未使用。
  -fsanitize-hwaddress-实验性别名
                          在 HWAddressSanitizer 中启用别名模式
  -fsanitize-ignorelist=<值>
                          消毒剂的忽略列表文件的路径
  -fsanitize-memory-track-origins=<值>
                          在 MemorySanitizer 中启用源跟踪
  -fsanitize-memory-track-origins
                          在 MemorySanitizer 中启用源跟踪
  -fsanitize-memory-use-after-dtor
                          在 MemorySanitizer 中启用 use-after-destroy 检测
  -fsanitize-最小运行时

  -fsanitize-recover=<值>
                          启用指定消毒剂的恢复
  -fsanitize-stats 启用消毒剂统计信息收集。
  -fsanitize-system-blacklist=<值>
                          -fsanitize-system-ignorelist= 的别名
  -fsanitize-system-ignorelist=<值>
                          用于消毒剂的系统忽略列表文件的路径
  -fsanitize-线程原子
                          在 ThreadSanitizer 中启用原子操作检测（默认）
  -fsanitize-thread-func-entry-exit
                          在 ThreadSanitizer 中启用函数进入/退出检测（默认）
  -fsanitize 线程内存访问
                          在 ThreadSanitizer 中启用内存访问检测（默认）
  -fsanitize-trap=<值> 为指定的消毒剂启用陷阱
  -fsanitize-trap 为所有消毒剂启用陷阱
  -fsanitize-undefined-strip-path-components=<数字>
                          在发出检查元数据时剥离（或仅保留，如果为负数）给定数量的路径组件。
  -fsanitize=<check> 为各种形式的未定义或可疑行为打开运行时检查。有关可用检查，请参阅用户手册
  -fsave-optimization-record=<格式>
                          生成特定格式的优化记录文件
  -fsave 优化记录
                          生成 YAML 优化记录文件
  -fseh-exceptions 使用 SEH 样式的异常
  -fsemantic-interposition

  -fshort-enums 只为枚举类型分配声明的可能值范围所需的字节数
  -fshort-wchar 强制 wchar_t 为短 unsigned int
  -fshow-列
  -fshow-overloads=<值>
                          当重载解析失败时显示哪些重载候选者：best|all; 默认为所有
  -fshow-skipped-includes 在 -H 输出中显示跳过的包含。
  -fshow-源位置
  -fsigned-char 字符已签名
  -fsigned-zeros
  -fsized-deallocation 启用 C++14 大小的全局释放函数
  -fsjlj-exceptions 使用 SjLj 样式的异常
  -fslp-vectorize 启用超字级并行向量化通道
  -fs 拼写检查
  -fsplit-dwarf-inlining 在对象/可执行文件中提供最少的调试信息，以便在使用拆分 DWARF 时在没有 .dwo/.dwp 文件的情况下促进在线符号化/堆栈跟踪
  -fsplit-lto-unit 启用 LTO 单元的拆分
  -fsplit-machine-functions
                          使用配置文件信息启用后期函数拆分 (x86 ELF)
  -fsplit-stack 使用分段堆栈
  -fstack-冲突保护
                          启用堆栈冲突保护
  -fstack-protector-all 为所有函数启用堆栈保护器
  -fstack-protector-强
                          为一些易受堆栈破坏的函数启用堆栈保护器。与 -fstack-protector 相比，它使用更强的启发式算法，包括包含任意大小（和任意类型）数组的函数，以及对 alloca 的任何调用或从局部变量中获取地址
  -fstack-protector 为一些易受堆栈破坏的函数启用堆栈保护器。这使用了一种松散的启发式方法，如果函数包含 char（或 8 位整数）数组或对 alloca 的常量大小的调用（其大小大于 ssp-buffer-size（默认值：8 字节）），则认为函数易受攻击。所有对 alloca 的可变大小调用都被认为是易受攻击的。具有堆栈保护器的函数具有添加到堆栈帧的保护值，该值在函数退出时进行检查。保护值必须位于堆栈帧中，这样易受攻击的变量的缓冲区溢出将在覆盖函数的返回地址之前覆盖保护值。引用堆栈保护值存储在全局变量中。
  -fstack-size-section 发出包含函数堆栈大小元数据的部分
  -fstack-usage 发出包含函数堆栈大小信息的 .su 文件
  -fstandalone-debug 为程序使用的所有类型发出完整的调试信息
  -fstrict-enums 根据枚举值范围的严格定义启用优化
  -fstrict-float-cast-overflow
                          假设溢出的浮点到整数转换是未定义的（默认）
  -fstrict-return
  -fstrict-vtable 指针
                          根据覆盖多态 C++ 对象的严格规则启用优化
  -fsycl 为设备启用 SYCL 内核编译
  -fsystem-module 将此模块构建为系统模块。仅与 -emit-module 一起使用
  -ftest-覆盖
  -fthin-link-bitcode=<值>
                          仅针对 ThinLTO 瘦链接将最小化位码写入 <file>
  -fthinlto-index=<值> 使用提供的函数摘要索引执行 ThinLTO 导入
  -fthreadsafe-statics
  -ftime-report=<value>（对于新的通行证管理器）“per-pass”：每个通行证一份报告；“per-pass-run”：每次调用调用一份报告
  -ftime-trace-granularity=<值>
                          时间分析器跟踪的最小时间粒度（以微秒为单位）
  -ftime-trace 打开时间分析器。根据输出文件名生成 JSON 文件。
  -ftrap-function=<值> 调用指定函数而不是陷阱指令
  -ftrapv-handler=<函数名>
                          指定溢出时调用的函数
  -ftrapv 整数溢出陷阱
  -ftrigraphs 处理三元组序列
  -ftrivial-auto-var-init-stop-after=<值>
                          在指定数量的实例之后停止初始化琐碎的自动堆栈变量
  -ftrivial-auto-var-init=<值>
                          初始化琐碎的自动堆栈变量：未初始化（默认）| 图案
  -funique-basic-block-section-names
                          对基本块部分使用唯一名称（仅限 ELF）
  -funique-internal-linkage-names
                          通过附加模块路径的 MD5 哈希来唯一化内部链接符号名称
  -funique-section-names
  -funroll-loops 打开循环展开器
  -fuse-cuid=<value> 为单源卸载语言 CUDA 和 HIP 的编译单元生成 ID 的方法：'hash'（通过散列文件路径和命令行选项生成的 ID）| 'random'（ID 生成为随机数）| “无”（禁用）。默认为“哈希”。如果已指定，此选项将被选项“-cuid=[ID]”覆盖。
  -fuse-cxa-atexit
  -fuse-init-array
  -fuse-line-directives 在预处理输出中使用#line
  -fvalidate-ast-input-files-content
                          计算并存储用于构建 AST 的输入文件的哈希值。如果两个内容相同，则认为 mtime 不匹配的文件是有效的
  -fveclib=<值> 使用给定的向量函数库
  -fvectorize 启用循环矢量化通道
  -fverbose-asm 生成详细汇编输出
  -f虚函数消除
                          启用死虚函数消除优化。需要 -flto=full
  -fvisibility-dllexport=<值>
                          dllexport 定义的可见性 [-fvisibility-from-dllstorageclass]
  -fvisibility-externs-dllimport=<值>
                          dllimport 外部声明的可见性 [-fvisibility-from-dllstorageclass]
  -fvisibility-externs-nodllstorageclass=<值>
                          没有显式 DLL dllstorageclass [-fvisibility-from-dllstorageclass] 的外部声明的可见性
  -fvisibility-from-dllstorageclass
                          从它们的 DLL 存储类中设置生成代码中符号的可见性
  -fvisibility-global-new-delete-hidden
                          为全局 C++ 运算符 new 和 delete 声明隐藏可见性
  -fvisibility-inlines-hidden-static-local-var
                          启用 -fvisibility-inlines-hidden 后，内联 C++ 成员函数中的静态变量也会默认隐藏可见性
  -fvisibility-inlines-hidden
                          默认情况下为内联 C++ 成员函数提供隐藏可见性
  -fvisibility-ms-compat 默认情况下为全局类型提供“默认”可见性以及全局函数和变量“隐藏”可见性
  -fvisibility-nodllstorageclass=<值>
                          没有显式 DLL 导出类的定义的可见性 [-fvisibility-from-dllstorageclass]
  -fvisibility=<值> 设置所有全局声明的默认符号可见性
  -fwasm-exceptions 使用 WebAssembly 样式的异常
  -fwhole-program-vtables 启用整个程序 vtable 优化。需要 -flto
  -fwrapv 将有符号整数溢出视为二进制补码
  -fwritable-strings 将字符串文字存储为可写数据
  -fxl-pragma-pack 启用 IBM XL #pragma pack 处理
  -fxray 始终发出自定义事件
                          即使不总是检测包含函数，也始终发出 __xray_customevent(...) 调用
  -fxray 始终发射类型事件
                          即使不总是检测包含函数，也始终发出 __xray_typedevent(...) 调用
  -fxray-always-instrument= <值>
                          已弃用：文件名定义了用于填充“始终仪器”XRay 属性的白名单。
  -fxray-attr-list= <值>
                          定义用于赋予 XRay 属性的函数/类型列表的文件名。
  -fxray-function-groups=<值>
                          只有 N 组中的仪器 1
  -fxray 功能索引
  -fxray-ignore-loops 不要使用循环检测函数，除非它们也满足最小函数大小
  -fxray-instruction-threshold= <值>
                          设置最小函数大小以使用 XRay 进行检测
  -fxray-instrumentation-bundle= <值>
                          选择要发射的 XRay 检测点。选项：all、none、function-entry、function-exit、function、custom。默认为“全部”。“function”包括“function-entry”和“function-exit”。
  -fxray-instrument 在函数进入和退出时生成 XRay 检测雪橇
  -fxray-link-deps 告诉 clang 添加 XRay 的链接依赖项。
  -fxray-modes= <值> 默认情况下链接到 XRay 检测二进制文件的模式列表。
  -fxray-never-instrument= <值>
                          已弃用：定义用于填充“从不仪器”XRay 属性的白名单的文件名。
  -fxray-selected-function-group=<值>
                          使用 -fxray-function-groups 时，选择要检测的函数组。有效范围是 0 到 fxray-function-groups - 1
  -fzero-initialized-in-bss

  -fzvector 启用 System z 矢量语言扩展
  -F <value> 将目录添加到框架包含搜索路径
  --gcc-toolchain=<value> 在常用 GCC 的目标上的指定目录中搜??索 GCC 安装。该目录通常包含 'lib{,32,64}/gcc{,-cross}/$triple' 和 'include'。如果指定，则会跳过 sysroot 进行 GCC 检测。注意：编译器使用的可执行文件（例如 ld）不会被选定的 GCC 安装覆盖
  -gcodeview-ghash 在 .debug$H 部分中发出类型记录哈希
  -gcodeview 生成 CodeView 调试信息
  -gcolumn 信息
  -gdwarf-2 使用 dwarf 版本 2 生成源级调试信息
  -gdwarf-3 使用 dwarf 版本 3 生成源级调试信息
  -gdwarf-4 使用 dwarf 版本 4 生成源级调试信息
  -gdwarf-5 使用 dwarf 版本 5 生成源级调试信息
  -gdwarf32 如果启用了调试信息发射，则为 ELF 二进制文件启用 DWARF32 格式。
  -gdwarf64 如果启用了调试信息发射，则为 ELF 二进制文件启用 DWARF64 格式。
  -gdwarf 使用默认的 dwarf 版本生成源级调试信息
  -gembed-source 在 DWARF 调试部分中嵌入源文本
  -ginline-line-tables
  -gline-directives-only 仅发出调试行信息指令
  -gline-tables-only 仅发出调试行号表
  -gmodules 使用对 clang 模块或预编译头文件的外部引用生成调试信息
  -gno-codeview-gash
  -gno 列信息
  -gno-embed-source 恢复在 DWARF 调试部分中不嵌入源文本的默认行为
  -gno-inline-line-tables 不发出内联行表。
  -gno-严格矮人
  --gpu-bundle-output HIP设备编译的Bundle输出文件
  --gpu-instrument-lib=<值>
                          HIP 的仪器设备库，它是一个包含 __cyg_profile_func_enter 和 __cyg_profile_func_exit 的 LLVM 位码
  --gpu-max-threads-per-block=<值>
                          HIP 的内核启动边界的每个块的默认最大线程数
  -gsplit-dwarf=<value> 将 DWARF 裂变模式设置为 'split' 或 'single'
  -gstrict-矮人
  -gz=<值> DWARF 调试部分压缩类型
  -G <size> 将最多 <size> 个字节的对象放入小数据部分（MIPS / Hexagon）
  -g 生成源级调试信息
  --help-hidden 显示隐藏选项的帮助
  -help 显示可用选项
  --hip-device-lib=<值>
                          HIP 设备库
  --hip-link 为 HIP 链接 clang-offload-bundler 包
  --hip-path=<value> HIP 运行时安装路径，用于查找 HIP 版本和添加 HIP 包含路径。
  --hip-version=<value> 格式为 major.minor.patch 的 HIP 版本
  -H 显示标题包括和嵌套深度
  -I- 将所有先前的 -I 标志限制为双引号包含并从包含路径中删除当前目录
  -ibuiltininc 即使在 -ibuiltininc 之前或之后使用 -nostdinc 也启用内置 #include 目录。在选项禁用后使用 -nobuiltininc
  -idirafter <value> 将目录添加到包含搜索路径之后
  -iframeworkwithsysroot <目录>
                          将目录添加到 SYSTEM 框架搜索路径，绝对路径是相对于 -isysroot 的
  -iframework <value> 将目录添加到 SYSTEM 框架搜索路径
  -imacros <file> 在解析之前包含文件中的宏
  -include-pch <file> 包含预编译的头文件
  -include <file> 解析前包含文件
  -index-header-map 使下一个包含的目录（-I 或 -F）成为索引器标题映射
  -iprefix <dir> 设置 -iwithprefix/-iwithprefixbefore 前缀
  -iquote <directory> 将目录添加到 QUOTE 包含搜索路径
  -isysroot <dir> 设置系统根目录（通常是/）
  -isystem-after <目录>
                          将目录添加到 SYSTEM 包含搜索路径的末尾
  -isystem <directory> 将目录添加到 SYSTEM 包含搜索路径
  -ivfsoverlay <value> 将file所描述的虚拟文件系统覆盖在真实文件系统之上
  -iwithprefixbefore <目录>
                          设置目录以包含带前缀的搜索路径
  -iwithprefix <dir> 将目录设置为 SYSTEM 包含带前缀的搜索路径
  -iwithsysroot <目录>
                          将目录添加到 SYSTEM 包含搜索路径，绝对路径是相对于 -isysroot 的
  -I <dir> 将目录添加到包含搜索路径列表的末尾
  --libomptarget-amdgcn-bc-path=<值>
                          libomptarget-amdgcn 位码库的路径
  --libomptarget-nvptx-bc-path=<值>
                          libomptarget-nvptx 位码库的路径
  -L <dir> 将目录添加到库搜索路径
  -mabi=vec-default 在 AIX 上启用默认的 Altivec ABI（仅限 AIX）。仅使用易失向量寄存器。
  -mabi=vec-extabi 在 AIX 上启用扩展的 Altivec ABI（仅限 AIX）。使用易失性和非易失性向量寄存器
  -mabicalls 启用 SVR4 风格的位置无关代码（仅限 Mips）
  -maix-struct-return 返回内存中的所有结构（仅限 PPC32）
  -malign-branch-boundary=<值>
                          指定边界的大小以对齐分支
  -malign-branch=<值> 指定要对齐的分支类型
  -malign-double 将结构中的两个单词对齐双精度（仅限 x86）
  -mamdgpu-ieee 在预期的默认浮点模式寄存器中设置 IEEE 位。根据 IEEE 754-2008 支持收集安静和传播信号 NaN 输入的异常标志的浮点操作码。此选项更改 ABI。（仅限 AMDGPU）
  -mbackchain 通过 System Z 上的 backchain 链接堆栈帧
  -mbranch-protection=<值>
                          强制执行间接分支和函数返回的目标
  -mbranches-within-32B-boundaries
                          在 32 字节边界内对齐选定的分支（fused、jcc、jmp）
  -mcmodel=medany 等效于 -mcmodel=medium，兼容 RISC-V gcc。
  -mcmodel=medlow 等价于 -mcmodel=small，兼容 RISC-V gcc。
  -mcmse 允许使用 CMSE（Armv8-M 安全扩展）
  -mcode-object-v3 用于指定代码对象 ABI V3 的旧选项（仅限 AMDGPU）
  -mcode-object-version=<版本>
                          指定代码对象 ABI 版本。默认为 3。（仅限 AMDGPU）
  -mcrc 允许使用 CRC 指令（仅限 ARM/Mips）
  -mcumode 指定 CU 波前执行模式（仅限 AMDGPU）
  -mdouble=<值> 强制双精度为 32 位或 64 位
  -MD 写一个包含用户和系统头文件的depfile
  -meabi <value> 设置 EABI 类型，例如 4、5 或 gnu（默认取决于三元组）
  -membedded-data 将常量放在 .rodata 部分而不是 .sdata 部分中，即使它们满足 -G <size> 阈值 (MIPS)
  -menable-experimental-extensions
                          启用实验性 RISC-V 扩展。
  -menable-unsafe-fp-math 允许不安全的浮点数学优化，这可能会降低精度
  -mexec-model=<值> 执行模型（仅限 WebAssembly）
  -mexecute-only 禁止生成对代码段的数据访问（仅限 ARM）
  -mextern-sdata 如果满足 -G <size> 阈值 (MIPS)，则假设外部定义的数据在小数据中
  -mfentry 在函数入口处插入对 fentry 的调用（仅限 x86/SystemZ）
  -mfix-cortex-a53-835769 解决方法 Cortex-A53 勘误表 835769（仅限 AArch64）
  -mfp32 使用 32 位浮点寄存器（仅限 MIPS）
  -mfp64 使用 64 位浮点寄存器（仅限 MIPS）
  -MF <file> 将 -MMD、-MD、-MM 或 -M 的 depfile 输出写入 <file>
  -mgeneral-regs-only 生成仅使用通用寄存器的代码（仅限 AArch64/x86）
  -mglobal-merge 启用全局合并
  -mgpopt 对已知位于小数据段 (MIPS) 中的符号使用 GP 相对访问
  -MG 将缺失的头文件添加到 depfile
  -mharden-sls=<值> 选择直线推测强化范围
  -mhvx-length=<值> 设置六边形向量长度
  -mhvx=<值> 启用六边形矢量扩展
  -mhvx 启用六边形矢量扩展
  -miamcu 使用 Intel MCU ABI
  -mignore-xcoff-可见性
                          在 AIX OS 中不发出 asm 的可见性属性或在 XCOFF 对象文件中为所有符号提供“未指定”可见性
  --migrate 运行迁移器
  -mincremental-linker-compatible
                          (integrated-as) 发出一个可以与增量链接器一起使用的目标文件
  -mindirect-jump=<值> 更改间接跳转指令以抑制推测
  -mios-version-min=<值>
                          设置 iOS 部署目标
  -MJ <value> 为每个输入写入一个编译数据库条目
  -mllvm <value> 附加参数转发到 LLVM 的选项处理
  -mlocal-sdata 将 -G 行为扩展到对象本地数据 (MIPS)
  -mlong-calls 生成具有扩展寻址能力的分支，通常通过间接跳转。
  -mlong-double-128 强制 long double 为 128 位
  -mlong-double-64 强制 long double 为 64 位
  -mlong-double-80 强制 long double 为 80 位，填充为 128 位进行存储
  -mlvi-cfi 仅启用负载值注入 (LVI) 的控制流缓解
  -mlvi-hardening 启用负载值注入 (LVI) 的所有缓解措施
  -mmacosx-version-min=<值>
                          设置 Mac OS X 部署目标
  -mmadd4 启用 4 操作数 madd.s、madd.d 和相关指令的生成。
  -mmark-bti-property 将带有 BTI 的 .note.gnu.property 添加到程序集文件（仅限 AArch64）
  -MMD 写一个包含用户头文件的depfile
  -mmemops 启用备忘录指令的生成
  -mms-bitfields 设置默认结构布局以兼容微软编译器标准
  -mmsa 启用 MSA ASE（仅限 MIPS）
  -mmt 启用 MT ASE（仅限 MIPS）
  -MM 与 -MMD 类似，但也暗示 -E 并默认写入标准输出
  -mno-abicalls 禁用 SVR4 风格的位置无关代码（仅限 Mips）
  -mno-amdgpu-ieee
  -mno-backchain
  -mno-code-object-v3 用于指定代码对象 ABI V2 的旧选项（仅限 AMDGPU）
  -mno-crc 禁止使用 CRC 指令（仅限 Mips）
  -mno-cumode 指定 WGP 波前执行模式（仅限 AMDGPU）
  -mno-embedded-data 如果常量满足 -G <size> 阈值 (MIPS)，请不要将常量放在 .rodata 部分而不是 .sdata 中
  -mno-execute-only 允许生成对代码段的数据访问（仅限 ARM）
  -mno-extern-sdata 如果满足 -G <size> 阈值 (MIPS)，则不要假设外部定义的数据在小数据中
  -mno-fix-cortex-a53-835769
                          不要解决 Cortex-A53 勘误表 835769（仅限 AArch64）
  -mno-global-merge 禁用全局合并
  -mno-gpopt 不要对已知位于小数据段 (MIPS) 中的符号使用 GP 相对访问
  -mno-hvx 禁用六边形向量扩展
  -mno-implicit-float 不生成隐式浮点指令
  -mno-incremental-linker-compatible
                          (integrated-as) 发出不能与增量链接器一起使用的目标文件
  -mno-local-sdata 不要将 -G 行为扩展到对象本地数据 (MIPS)
  -mno-long-calls 恢复不生成长调用的默认行为
  -mno-lvi-cfi 禁用负载值注入 (LVI) 的控制流缓解
  -mno-lvi-hardening 禁用负载值注入 (LVI) 的缓解措施
  -mno-madd4 禁用 4 操作数 madd.s、madd.d 和相关指令的生成。
  -mno-memops 禁止生成 memop 指令
  -mno-movt 禁止使用 movt/movw 对（仅限 ARM）
  -mno-ms-bitfields 不要将默认结构布局设置为与 Microsoft 编译器标准兼容
  -mno-msa 禁用 MSA ASE（仅限 MIPS）
  -mno-mt 禁用 MT ASE（仅限 MIPS）
  -mno-neg-immediates 禁止将带有负立即数的指令转换为它们的否定或反转。
  -mno-nvj 禁止生成新值跳转
  -mno-nvs 禁用新值存储的生成
  -mno-outline-atomics 不生成对离线原子操作的本地调用
  -mno-outline 禁用函数大纲（仅限 AArch64）
  -mno-packets 禁止生成指令包
  -mno-relax 禁用链接器松弛
  -mno-restrict-it 允许为 ARMv8 生成已弃用的 IT 块。ARMv8 Thumb 模式默认关闭
  -mno-save-restore 禁用使用库调用进行保存和恢复
  -mno-seses 禁用推测执行副作用抑制 (SESES)
  -mno-speculative-load-hardening

  -mno-stack-arg-probe 禁用默认启用的堆栈探测器
  -mno-tgsplit 禁用线程组拆分执行模式（仅限 AMDGPU）
  -mno-tls-direct-seg-refs
                          通过段寄存器禁用直接 TLS 访问
  -mno-unaligned-access 强制所有内存访问对齐（仅限 AArch32/AArch64）
  -mno-unsafe-fp-atomics
  -mno-wavefrontsize64 指定波前大小 32 模式（仅限 AMDGPU）
  -mnocrc 禁止使用 CRC 指令（仅限 ARM）
  -mnop-mcount 生成 mcount/__fentry__ 调用作为 nops。要激活它们，需要对其进行修补。
  -mnvj 启用新值跳转的生成
  -mnvs 启用新值存储的生成
  -module-dependency-dir <值>
                          将模块依赖项转储到的目录
  -module-file-info 提供有关特定模块文件的信息
  -momit 叶帧指针
                          省略叶函数的帧指针设置
  -moutline-atomics 生成对离线原子操作的本地调用
  -moutline 启用函数大纲（仅限 AArch64）
  -mpacked-stack 使用打包堆栈布局（仅限 SystemZ）。
  -mpackets 启用指令包的生成
  -mpad-max-prefix-size=<值>
                          指定用于填充的最大前缀数
  -mprefer-vector-width=<值>
                          指定自动矢量化的首选矢量宽度。默认为“无”，允许针对特定的决策。
  -MP 为每个依赖项创建虚假目标（除了主文件）
  -mqdsp6-compat 启用 hexagon-qdsp6 向后兼容
  -MQ <value> 指定要在 depfile 中引用的主文件输出的名称
  -mrecord-mcount 为每个 __fentry__ 调用生成一个 __mcount_loc 部分条目。
  -mrelax-all (integrated-as) 放宽所有机器指令
  -mrelax 启用链接器松弛
  -mrestrict-it 禁止为 ARMv8 生成已弃用的 IT 块。ARMv8 Thumb 模式默认开启。
  -mrtd 将 StdCall 调用约定设为默认值
  -msave-restore 启用使用库调用进行保存和恢复
  -mseses 启用推测执行副作用抑制 (SESES)。包括 LVI 控制流完整性缓解措施
  -msign-return-address=<值>
                          选择返回地址签名范围
  -msmall-data-limit=<值>
                          将小于限制的全局和静态数据放入特殊部分
  -msoft-float 使用软件浮点
  -mspeculative-load-hardening

  -mstack-alignment=<值>
                          设置堆栈对齐
  -mstack-arg-probe 启用堆栈探测
  -mstack-probe-size=<值>
                          设置堆栈探针大小
  -mstack-protector-guard-offset=<值>
                          使用给定的偏移量来寻址堆栈保护器保护
  -mstack-protector-guard-reg=<值>
                          使用给定的 reg 寻址堆栈保护器保护
  -mstack-protector-guard=<值>
                          使用给定的守卫（全局，tls）来寻址堆栈保护器守卫
  -mstackrealign 强制在每个函数的入口处重新对齐堆栈
  -msve-vector-bits=<值>
                          指定 SVE 向量寄存器的位大小。默认为“可扩展”的向量长度不可知值。（仅限 AArch64）
  -msvr4-struct-return 在寄存器中返回小结构（仅限 PPC32）
  -mtgsplit 启用线程组拆分执行模式（仅限 AMDGPU）
  -mthread-model <value> 要使用的线程模型，例如posix，single（默认为posix）
  -mtls-direct-seg-refs 通过段寄存器启用直接 TLS 访问（默认）
  -mtls-size=<值> 指定立即 TLS 偏移的位大小（仅限 AArch64 ELF）：12（对于 4KB）| 24（16MB，默认）| 32（4GB）| 48（对于 256TB，需要 -mcmodel=large）
  -mtp=<值> 线程指针访问方法（仅限 AArch32/AArch64）
  -mtune=<值> 仅在 X86 和 RISC-V 上受支持。否则接受与 GCC 的兼容性。
  -MT <value> 指定 depfile 中主文件输出的名称
  -munaligned-access 允许内存访问不对齐（仅限 AArch32/AArch64）
  -munsafe-fp-atomics 启用不安全的浮点原子指令（仅限 AMDGPU）
  -MV 对 depfile 使用 NMake/Jom 格式
  -mwavefrontsize64 指定波前大小 64 模式（仅限 AMDGPU）
  -M 与 -MD 类似，但也暗示 -E 并默认写入标准输出
  --no-cuda-include-ptx=<值>
                          不要为以下 GPU 架构（例如 sm_35）或“全部”包含 PTX。可以多次指定。
  --no-cuda-version-check 如果检测到的 CUDA 安装版本对于请求的 CUDA gpu 架构来说太低，则不要出错。
  --no-gpu-bundle-output 不捆绑HIP设备编译的输出文件
  --no-offload-arch=<值>
                          从要编译的设备列表中删除 CUDA/HIP 卸载设备架构（例如 sm_35、gfx906）。'all' 将列表重置为其默认值。
  -no-pthread
  --no-system-header-prefix=<前缀>
                          将所有以 <prefix> 开头的#include 路径视为不包括系统标头。
  -nobuiltininc 禁用内置#include 目录
  -nogpuinc 不为 CUDA/HIP 添加包含路径，也不包含默认的 CUDA/HIP 包装头
  -nogpulib 不为 CUDA/HIP 设备编译链接设备库
  -nostdinc++ 禁用 C++ 标准库的标准 #include 目录
  -ObjC++ 将源输入文件视为 Objective-C++ 输入
  -objcmt-atomic-property 迁移到“原子”属性
  -objcmt-migrate-all 启用迁移到现代 ObjC
  -objcmt-迁移注释
                          启用迁移到属性和方法注释
  -objcmt-迁移-指定-init
                          启用迁移以推断初始化方法的 NS_DESIGNATED_INITIALIZER
  -objcmt-迁移实例类型
                          启用迁移以推断方法结果类型的实例类型
  -objcmt-迁移文字
                          启用向现代 ObjC 文字的迁移
  -objcmt-迁移-ns-宏
                          启用迁移到 NS_ENUM/NS_OPTIONS 宏
  -objcmt-migrate-property-dot-syntax
                          启用将 setter/getter 消息迁移到属性点语法
  -objcmt-迁移属性
                          启用迁移到现代 ObjC 属性
  -objcmt 迁移协议一致性
                          启用迁移以在类上添加协议一致性
  -objcmt-迁移只读属性
                          启用迁移到现代 ObjC 只读属性
  -objcmt-迁移读写属性
                          启用迁移到现代 ObjC 读写属性
  -objcmt-迁移下标
                          启用迁移到现代 ObjC 下标
  -objcmt-ns-nonatomic-iosonly
                          启用迁移以使用 NS_NONATOMIC_IOSONLY 宏来设置属性的“原子”属性
  -objcmt-returns-innerpointer-property
                          启用迁移以使用 NS_RETURNS_INNER_POINTER 注释属性
  -objcmt-whitelist-dir-path=<值>
                          仅修改文件名包含在提供的目录路径中的文件
  -ObjC 将源输入文件视为 Objective-C 输入
  --offload-arch=<值> CUDA 卸载设备架构（例如 sm_35），或以设备架构形式的 HIP 卸载目标 ID，后跟以冒号分隔的目标 ID 特征。每个目标 ID 特征都是一个预定义的字符串，后跟一个加号或减号（例如 gfx908:xnack+:sramecc-）。可以多次指定。
  -o <file> 将输出写入 <file>
  -pedantic 语言扩展警告
  -pg 启用 mcount 检测
  -pipe 尽可能在命令之间使用管道
  --precompile 只预编译输入
  -print-effective-triple 打印有效目标三元组
  -print-file-name=<file> 打印 <file> 的完整库路径
  -print-ivar-layout 启用 Objective-C Ivar 布局位图打印跟踪
  -print-libgcc-file-name 打印当前使用的编译器运行时库的库路径（“libgcc.a”或“libclang_rt.builtins.*.a”）
  -print-multiarch 打印多架构目标三元组
  -print-prog-name=<name> 打印 <name> 的完整程序路径
  -print-resource-dir 打印资源目录路径名
  -print-rocm-search-dirs 打印用于查找 ROCm 安装的路径
  -print-runtime-dir 打印包含 clangs 运行时库的目录路径名
  -print-search-dirs 打印用于查找库和程序的路径
  -print-supported-cpus 为给定目标打印支持的 cpu 模型（如果未指定目标，它将为默认目标打印支持的 cpu）
  -print-target-triple 打印标准化的目标三元组
  -print-targets 打印注册的目标
  -pthread 在生成的代码中支持 POSIX 线程
  --ptxas-path=<value> ptxas 的路径（用于编译 CUDA 代码）
  -P 在 -E 模式下禁用线标记输出
  -Qn 不发出包含编译器名称和版本的元数据
  -Qunused-arguments 不要为未使用的驱动程序参数发出警告
  -Qy 发出包含编译器名称和版本的元数据
  -relocatable-pch 是否构建可重定位的预编译头文件
  -rewrite-legacy-objc 将旧版 Objective-C 源代码重写为 C++
  -rewrite-objc 将 Objective-C 源代码重写为 C++
  --rocm-device-lib-path=<值>
                          ROCm 设备库路径。替代 rocm-path。
  --rocm-path=<value> ROCm 安装路径，用于查找和自动链接所需的位码库。
  -Rpass-analysis=<值> 报告来自名称与给定 POSIX 正则表达式匹配的优化过程的转换分析
  -Rpass-missed=<值> 通过名称与给定 POSIX 正则表达式匹配的优化通道报告丢失的转换
  -Rpass=<value> 报告由名称与给定 POSIX 正则表达式匹配的优化通道执行的转换
  -rtlib=<值> 要使用的编译器运行时库
  -R<remark> 启用指定的备注
  -save-stats=<值> 保存 llvm 统计信息。
  -save-stats 保存 llvm 统计信息。
  -save-temps=<值> 保存中间编译结果。
  -save-temps 保存中间编译结果
  -序列化诊断<值>
                          将编译器诊断序列化到文件
  -shared-libsan 动态链接 sanitizer 运行时
  -static-libsan 静态链接 sanitizer 运行时
  -static-openmp 链接时使用静态主机 OpenMP 运行时。
  -std=<值> 编译的语言标准
  -stdlib++-isystem <目录>
                          使用目录作为 C++ 标准库包含路径
  -stdlib=<值> 要使用的 C++ 标准库
  -sycl-std=<值> 要编译的 SYCL 语言标准。
  --system-header-prefix=<前缀>
                          将所有以 <prefix> 开头的#include 路径视为包含系统标头。
  -S 只运行预处理和编译步骤
  --target=<value> 为给定目标生成代码
  -tbss <addr> 设置BSS的起始地址为<addr>
  -Tdata <addr> 设置DATA的起始地址为<addr>
  -time 时间单个命令
  -traditional-cpp 启用一些传统的 CPP 仿真
  -trigraphs 处理三元组序列
  -Ttext <addr> 设置TEXT的起始地址为<addr>
  -T <script> 指定 <script> 为链接描述文件
  -undef undef 所有系统定义
  -unwindlib=<值> 展开要使用的库
  -U <宏> 取消定义宏<宏>
  --verify-debug-info 验证调试输出的二进制表示
  -verify-pch 加载并验证预编译的头文件是否过时
  --version 打印版本信息
  -v 显示命令以运行和使用详细输出
  -Wa,<arg> 将 <arg> 中的逗号分隔参数传递给汇编器
  -Wdeprecated 为不推荐使用的构造启用警告并定义 __DEPRECATED
  -Wl,<arg> 将 <arg> 中的逗号分隔参数传递给链接器
  -工作目录 <值>
                          解析相对于指定目录的文件路径
  -Wp,<arg> 将 <arg> 中的逗号分隔参数传递给预处理器
  -W<warning> 启用指定的警告
  -w 禁止所有警告
  -Xanalyzer <arg> 将 <arg> 传递给静态分析器
  -Xarch_device <arg> 将 <arg> 传递给 CUDA/HIP 设备编译
  -Xarch_host <arg> 将 <arg> 传递给 CUDA/HIP 主机编译
  -Xassembler <arg> 将 <arg> 传递给汇编器
  -Xclang <arg> 将 <arg> 传递给 clang 编译器
  -Xcuda-fatbinary <arg> 将 <arg> 传递给 fatbinary 调用
  -Xcuda-ptxas <arg> 将 <arg> 传递给 ptxas 汇编器
  -Xlinker <arg> 将 <arg> 传递给链接器
  -Xopenmp-target=<三重> <arg>
                          将 <arg> 传递给由 <triple> 标识的目标卸载工具链。
  -Xopenmp-target <arg> 将 <arg> 传递给目标卸载工具链。
  -Xpreprocessor <arg> 将 <arg> 传递给预处理器
  -x <语言> 将后续输入文件视为具有类型 <语言>
  -z <arg> 将 -z <arg> 传递给链接器
PS C:\用户\管理员\桌面>